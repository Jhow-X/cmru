import OpenAI from "openai";
import fs from "fs"; // You'll need to install 'fs' if running in a browser-like environment, or adjust for your file handling

// o modelo OpenAI mais recente é "gpt-4o", lançado em 13 de maio de 2024. Não altere isso a menos que solicitado explicitamente pelo usuário.
const DEFAULT_MODEL = "gpt-4o";

// Inicializar o cliente OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || "",
});
const mySecret = process.env["OPENAI_API_KEY"];
console.log("Minha chave API é: ", mySecret);

let assistantId = null;
let vectorStoreId = null;

/**
 * Configura o assistente OpenAI com a funcionalidade de busca de arquivos.
 * Cria um vector store, faz o upload dos arquivos e anexa-os ao assistente.
 * @param {string[]} filePaths - Caminhos para os arquivos a serem carregados.
 */
export async function setupAssistantWithFiles(filePaths) {
  try {
    console.log("Configurando assistente com arquivos...");

    // 1. Criar um vector store
    const vectorStore = await openai.vectorStores.create({
      name: "Armazenamento de Documentos Legais",
    });
    vectorStoreId = vectorStore.id;
    console.log("Vector Store criado com ID:", vectorStoreId);

    // 2. Fazer upload dos arquivos e adicioná-los ao vector store
    const fileStreams = filePaths.map((path) => fs.createReadStream(path));
    await openai.vectorStores.fileBatches.uploadAndPoll(
      vectorStoreId,
      fileStreams
    );
    console.log("Arquivos carregados e adicionados ao Vector Store.");

    // 3. Criar ou atualizar o assistente para usar o novo Vector Store
    const assistant = await openai.beta.assistants.create({
      name: "Assistente Jurídico Especializado",
      instructions: "Você é um assistente jurídico especializado. Use seu conhecimento base e os documentos fornecidos para responder às perguntas do usuário de forma precisa e útil.",
      model: DEFAULT_MODEL,
      tools: [{ type: "file_search" }],
      tool_resources: {
        file_search: {
          vector_store_ids: [vectorStoreId],
        },
      },
    });
    assistantId = assistant.id;
    console.log("Assistente criado/atualizado com ID:", assistantId);
    console.log("Assistente configurado com sucesso para busca de arquivos.");
  } catch (error) {
    console.error("Erro ao configurar o assistente com arquivos:", error);
    throw new Error("Erro ao configurar o assistente. Tente novamente.");
  }
}

/**
 * Função para gerar uma resposta de um GPT com configuração personalizada.
 * Utiliza o Assistente OpenAI com busca de arquivos.
 * @param {string} message - A mensagem do usuário.
 * @param {string} systemInstructions - Instruções do sistema para o GPT.
 * @param {string} model - O modelo do GPT a ser usado.
 * @param {number} temperature - A temperatura da geração (0-100).
 * @returns {Promise<string>} A resposta gerada pelo GPT.
 */
export async function generateGptResponse(
  message,
  systemInstructions,
  model = DEFAULT_MODEL,
  temperature = 70
) {
  if (!assistantId) {
    throw new Error("O assistente não está configurado. Chame 'setupAssistantWithFiles' primeiro.");
  }

  try {
    // 1. Criar um thread
    const thread = await openai.beta.threads.create({
      messages: [
        {
          role: "user",
          content: message,
        },
      ],
      // O assistente usará o vector store anexado a ele
    });
    console.log("Thread criada com ID:", thread.id);

    // 2. Criar uma execução no thread
    const run = await openai.beta.threads.runs.create(thread.id, {
      assistant_id: assistantId,
      instructions: systemInstructions, // As instruções do sistema podem ser passadas aqui
    });
    console.log("Execução iniciada com ID:", run.id);

    // 3. Esperar a execução ser concluída
    let runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
    while (runStatus.status === "queued" || runStatus.status === "in_progress") {
      await new Promise((resolve) => setTimeout(resolve, 1000)); // Espera 1 segundo antes de verificar novamente
      runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
    }

    if (runStatus.status === "completed") {
      const messages = await openai.beta.threads.messages.list(thread.id);
      const lastMessage = messages.data
        .filter(
          (msg) => msg.run_id === run.id && msg.role === "assistant"
        )
        .pop();

      if (lastMessage && lastMessage.content) {
        // Encontra o primeiro conteúdo de texto
        const textContent = lastMessage.content.find(content => content.type === 'text');
        if (textContent) {
          return textContent.text.value;
        }
      }
      return "Desculpe, não consegui gerar uma resposta.";
    } else {
      console.error("Status da execução:", runStatus.status);
      return "Desculpe, a execução do assistente não foi concluída com sucesso.";
    }
  } catch (error) {
    console.error("Erro ao gerar resposta do GPT:", error);
    throw new Error("Erro ao processar sua mensagem. Tente novamente.");
  }
}

/**
 * Função para analisar documentos legais.
 * @param {string} documentText - O texto do documento legal a ser analisado.
 * @returns {Promise<string>} A análise do documento.
 */
export async function analyzeLegalDocument(documentText) {
  const systemPrompt = `
    Você é um assistente jurídico especializado na análise de documentos legais.
    Sua tarefa é analisar o documento fornecido e extrair:
    1. Principais pontos legais
    2. Possíveis problemas ou inconsistências
    3. Referências a leis e jurisprudência relevantes
    4. Recomendações para o magistrado
    
    Forneça sua análise de forma estruturada e concisa.
  `;

  return generateGptResponse(documentText, systemPrompt);
}

/**
 * Função para redigir respostas legais.
 * @param {string} caseDetails - Detalhes do caso.
 * @param {string} responseType - O tipo de resposta legal a ser redigida.
 * @returns {Promise<string>} A resposta legal redigida.
 */
export async function draftLegalResponse(caseDetails, responseType) {
  const systemPrompt = `
    Você é um assistente jurídico especializado na redação de documentos legais.
    Sua tarefa é redigir um(a) ${responseType} com base nos detalhes do caso fornecido.
    Use linguagem formal e jurídica apropriada.
    Estruture o documento conforme os padrões jurídicos brasileiros.
    Inclua citações de leis e jurisprudência relevantes quando apropriado.
  `;

  return generateGptResponse(caseDetails, systemPrompt);
}

/**
 * Função para obter referências legais.
 * @param {string} query - A consulta para referências legais.
 * @returns {Promise<string>} As referências legais.
 */
export async function getLegalReferences(query) {
  const systemPrompt = `
    Você é um assistente jurídico especializado em pesquisa legal.
    Sua tarefa é fornecer referências legais relevantes para a consulta fornecida, incluindo:
    1. Leis e códigos aplicáveis
    2. Jurisprudência relevante
    3. Doutrinas e entendimentos predominantes
    4. Súmulas e orientações de tribunais superiores
    
    Forneça sua resposta de forma estruturada e com citações precisas.
  `;

  return generateGptResponse(query, systemPrompt);
}

/**
 * Função para obter modelos GPT disponíveis.
 * @returns {Promise<string[]>} Uma lista de IDs de modelos disponíveis.
 */
export async function getAvailableModels() {
  try {
    const list = await openai.models.list();
    const models = [];

    for await (const model of list) {
      // Filtrar para incluir apenas modelos GPT comumente usados
      if (
        model.id.includes("gpt") &&
        !model.id.includes("instruct") &&
        !model.id.includes("babbage") &&
        !model.id.includes("ada") &&
        !model.id.includes("davinci")
      ) {
        models.push(model.id);
      }
    }

    // Ordenar modelos do mais novo para o mais antigo
    return models.sort().reverse();
  } catch (error) {
    console.error("Erro ao obter modelos disponíveis:", error);
    // Retornar modelos de fallback se a API falhar
    return ["gpt-4o", "gpt-4", "gpt-4-turbo", "gpt-3.5-turbo"];
  }
}

export default {
  setupAssistantWithFiles,
  generateGptResponse,
  analyzeLegalDocument,
  draftLegalResponse,
  getLegalReferences,
  getAvailableModels,
};
